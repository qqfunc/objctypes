from typing import Self, final, overload

@final  # NOTE: final?
class ObjCClass(type):  # NOTE: type?
    @overload
    def __new__(cls, name: str, /) -> ObjCClass: ...
    @overload
    def __new__(
        cls,
        name: str,
        bases: tuple[type, ...],
        namespace: dict[str, object],
        /,
    ) -> ObjCClass: ...
    @classmethod
    def from_address(cls, address: int, /) -> ObjCClass: ...
    @property
    def address(cls) -> int: ...
    @property
    def name(cls) -> str: ...

class ObjCObject(metaclass=ObjCClass):
    def __new__(cls, *args: tuple[object, ...]) -> Self: ...
    @classmethod
    def from_address(cls, address: int, /) -> Self: ...
    @property
    def address(self) -> int: ...

@final
class ObjCMethod:
    @classmethod
    def from_address(cls, address: int, /) -> Self: ...
    @property
    def address(self) -> int: ...
    @property
    def name(self) -> str: ...

@final
class ObjCSelector:
    def __new__(cls, name: str = ..., /) -> Self: ...
    @classmethod
    def from_address(cls, address: int, /) -> Self: ...
    @property
    def address(self) -> int: ...
    @property
    def name(self) -> str: ...

@final
class ObjCBool:
    def __new__(cls, value: object = ..., /) -> Self: ...
    def __bool__(self) -> bool: ...
    def __and__(self, other: Self) -> Self: ...
    def __xor__(self, other: Self) -> Self: ...
    def __or__(self, other: Self) -> Self: ...
    def __invert__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...

YES: ObjCBool
NO: ObjCBool
